---
description:
globs:
alwaysApply: true
---
# ä»£ç è´¨é‡ä¸æµ‹è¯•æ ‡å‡†

## ğŸ“ TypeScript ä»£ç è§„èŒƒ

### ç±»å‹å®šä¹‰è§„èŒƒ
```typescript
// âœ… æ­£ç¡®ï¼šæ˜ç¡®çš„ç±»å‹å®šä¹‰
interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

interface CreateUserRequest {
  email: string;
  name: string;
  password: string;
}

// âŒ é¿å…ï¼šany ç±»å‹
function processData(data: any): any {
  return data;
}

// âœ… æ­£ç¡®ï¼šæ³›å‹çº¦æŸ
function processData<T extends Record<string, unknown>>(data: T): T {
  return data;
}
```

### é”™è¯¯å¤„ç†è§„èŒƒ
```typescript
// âœ… æ­£ç¡®ï¼šå…·ä½“çš„é”™è¯¯ç±»å‹
import {
  BadRequestException,
  NotFoundException,
  ConflictException
} from '@nestjs/common';

@Injectable()
export class UsersService {
  async createUser(createUserDto: CreateUserDto): Promise<User> {
    try {
      // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
      const existingUser = await this.findByEmail(createUserDto.email);
      if (existingUser) {
        throw new ConflictException('é‚®ç®±å·²è¢«æ³¨å†Œ');
      }

      return await this.userRepository.create(createUserDto);
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }

      this.logger.error(`åˆ›å»ºç”¨æˆ·å¤±è´¥: ${error.message}`, error.stack);
      throw new BadRequestException('åˆ›å»ºç”¨æˆ·å¤±è´¥');
    }
  }

  async findById(id: string): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new NotFoundException(`ç”¨æˆ· ${id} ä¸å­˜åœ¨`);
    }
    return user;
  }
}
```

### æ—¥å¿—è®°å½•è§„èŒƒ
å‚è€ƒ [src/common/configs/logger.config.ts](mdc:src/common/configs/logger.config.ts)ï¼š

```typescript
@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name);

  async createUser(createUserDto: CreateUserDto): Promise<User> {
    this.logger.log(`å¼€å§‹åˆ›å»ºç”¨æˆ·: ${createUserDto.email}`);

    try {
      const user = await this.userRepository.create(createUserDto);
      this.logger.log(`ç”¨æˆ·åˆ›å»ºæˆåŠŸ: ${user.id}`);
      return user;
    } catch (error) {
      this.logger.error(
        `ç”¨æˆ·åˆ›å»ºå¤±è´¥: ${createUserDto.email}`,
        error.stack,
        'UsersService'
      );
      throw error;
    }
  }
}
```

## ğŸ§ª æµ‹è¯•æ ‡å‡†è§„èŒƒ

### å•å…ƒæµ‹è¯•è§„èŒƒ
å‚è€ƒé¡¹ç›®ä¸­çš„æµ‹è¯•æ–‡ä»¶ç»“æ„ï¼š

#### Controller æµ‹è¯•
å‚è€ƒ [src/user/user.controller.spec.ts](mdc:src/user/user.controller.spec.ts)ï¼š

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

describe('UsersController', () => {
  let controller: UsersController;
  let service: UsersService;

  const mockUsersService = {
    create: jest.fn(),
    findAll: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [
        {
          provide: UsersService,
          useValue: mockUsersService,
        },
      ],
    }).compile();

    controller = module.get<UsersController>(UsersController);
    service = module.get<UsersService>(UsersService);
  });

  it('åº”è¯¥è¢«å®šä¹‰', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('åº”è¯¥åˆ›å»ºç”¨æˆ·æˆåŠŸ', async () => {
      const createUserDto = {
        email: 'test@example.com',
        name: 'Test User',
        password: 'Password123!',
      };
      const expectedUser = { id: '1', ...createUserDto };

      mockUsersService.create.mockResolvedValue(expectedUser);

      const result = await controller.create(createUserDto);

      expect(service.create).toHaveBeenCalledWith(createUserDto);
      expect(result).toEqual(expectedUser);
    });
  });

  describe('findAll', () => {
    it('åº”è¯¥è¿”å›ç”¨æˆ·åˆ—è¡¨', async () => {
      const expectedUsers = [
        { id: '1', email: 'user1@example.com', name: 'User 1' },
        { id: '2', email: 'user2@example.com', name: 'User 2' },
      ];

      mockUsersService.findAll.mockResolvedValue(expectedUsers);

      const result = await controller.findAll('1', '10');

      expect(service.findAll).toHaveBeenCalledWith(1, 10);
      expect(result).toEqual(expectedUsers);
    });
  });
});
```

#### Service æµ‹è¯•
å‚è€ƒ [src/user/user.service.spec.ts](mdc:src/user/user.service.spec.ts)ï¼š

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';
import { GlobalService } from '../global/global.service';
import { NotFoundException, ConflictException } from '@nestjs/common';

describe('UsersService', () => {
  let service: UsersService;
  let globalService: GlobalService;

  const mockPrisma = {
    user: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  };

  const mockGlobalService = {
    getPrisma: jest.fn().mockReturnValue(mockPrisma),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: GlobalService,
          useValue: mockGlobalService,
        },
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);
    globalService = module.get<GlobalService>(GlobalService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('åº”è¯¥è¢«å®šä¹‰', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('åº”è¯¥åˆ›å»ºç”¨æˆ·æˆåŠŸ', async () => {
      const createUserDto = {
        email: 'test@example.com',
        name: 'Test User',
        password: 'hashedPassword',
      };
      const expectedUser = { id: '1', ...createUserDto };

      mockPrisma.user.findUnique.mockResolvedValue(null); // é‚®ç®±ä¸å­˜åœ¨
      mockPrisma.user.create.mockResolvedValue(expectedUser);

      const result = await service.create(createUserDto);

      expect(mockPrisma.user.create).toHaveBeenCalledWith({
        data: createUserDto,
      });
      expect(result).toEqual(expectedUser);
    });

    it('é‚®ç®±å·²å­˜åœ¨æ—¶åº”è¯¥æŠ›å‡ºå†²çªå¼‚å¸¸', async () => {
      const createUserDto = {
        email: 'existing@example.com',
        name: 'Test User',
        password: 'hashedPassword',
      };
      const existingUser = { id: '1', email: 'existing@example.com' };

      mockPrisma.user.findUnique.mockResolvedValue(existingUser);

      await expect(service.create(createUserDto)).rejects.toThrow(
        ConflictException,
      );
    });
  });

  describe('findOne', () => {
    it('åº”è¯¥è¿”å›ç”¨æˆ·', async () => {
      const userId = '1';
      const expectedUser = { id: userId, email: 'test@example.com' };

      mockPrisma.user.findUnique.mockResolvedValue(expectedUser);

      const result = await service.findOne(userId);

      expect(mockPrisma.user.findUnique).toHaveBeenCalledWith({
        where: { id: userId },
      });
      expect(result).toEqual(expectedUser);
    });

    it('ç”¨æˆ·ä¸å­˜åœ¨æ—¶åº”è¯¥æŠ›å‡ºæœªæ‰¾åˆ°å¼‚å¸¸', async () => {
      const userId = 'non-existent';

      mockPrisma.user.findUnique.mockResolvedValue(null);

      await expect(service.findOne(userId)).rejects.toThrow(
        NotFoundException,
      );
    });
  });
});
```

### é›†æˆæµ‹è¯•è§„èŒƒ

#### E2E æµ‹è¯•
å‚è€ƒ [test/app.e2e-spec.ts](mdc:test/app.e2e-spec.ts)ï¼š

```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('Users (e2e)', () => {
  let app: INestApplication;
  let jwtToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // ç™»å½•è·å–token
    const loginResponse = await request(app.getHttpServer())
      .post('/auth/login')
      .send({
        email: 'admin@example.com',
        password: 'admin123',
      })
      .expect(200);

    jwtToken = loginResponse.body.data.accessToken;
  });

  afterAll(async () => {
    await app.close();
  });

  describe('/users (POST)', () => {
    it('åº”è¯¥åˆ›å»ºæ–°ç”¨æˆ·', () => {
      return request(app.getHttpServer())
        .post('/users')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send({
          email: 'newuser@example.com',
          name: 'New User',
          password: 'Password123!',
        })
        .expect(201)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(res.body.data.email).toBe('newuser@example.com');
          expect(res.body.data.password).toBeUndefined(); // å¯†ç ä¸åº”è¿”å›
        });
    });

    it('é‚®ç®±æ ¼å¼é”™è¯¯æ—¶åº”è¯¥è¿”å›400', () => {
      return request(app.getHttpServer())
        .post('/users')
        .set('Authorization', `Bearer ${jwtToken}`)
        .send({
          email: 'invalid-email',
          name: 'User',
          password: 'Password123!',
        })
        .expect(400);
    });
  });

  describe('/users (GET)', () => {
    it('åº”è¯¥è¿”å›ç”¨æˆ·åˆ—è¡¨', () => {
      return request(app.getHttpServer())
        .get('/users')
        .set('Authorization', `Bearer ${jwtToken}`)
        .expect(200)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(Array.isArray(res.body.data)).toBe(true);
        });
    });

    it('æœªè®¤è¯æ—¶åº”è¯¥è¿”å›401', () => {
      return request(app.getHttpServer())
        .get('/users')
        .expect(401);
    });
  });
});
```

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

#### é…ç½®Jestè¦†ç›–ç‡
å‚è€ƒ [package.json](mdc:package.json) ä¸­çš„jesté…ç½®ï¼š

```json
{
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.(t|j)s",
      "!src/main.ts",
      "!src/**/*.module.ts",
      "!src/**/*.dto.ts",
      "!src/**/*.interface.ts"
    ],
    "coverageDirectory": "../coverage",
    "coverageReporters": ["text", "lcov", "html"],
    "coverageThresholds": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

## ğŸ” ä»£ç è´¨é‡å·¥å…·

### ESLint é…ç½®è§„èŒƒ
```json
{
  "extends": [
    "@nestjs/eslint-config-nestjs"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "error",
    "prefer-const": "error",
    "no-var": "error"
  }
}
```

### Prettier ä»£ç æ ¼å¼åŒ–
```json
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

### Husky Git Hooks
```json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,ts}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{md,json}": [
      "prettier --write"
    ]
  }
}
```

## ğŸ“‹ ä»£ç è´¨é‡æ£€æŸ¥æ¸…å•

### å¼€å‘å‰æ£€æŸ¥
- [ ] ç±»å‹å®šä¹‰å®Œæ•´å‡†ç¡®
- [ ] æ¥å£è®¾è®¡ç¬¦åˆè§„èŒƒ
- [ ] é”™è¯¯å¤„ç†ç­–ç•¥æ˜ç¡®
- [ ] æ—¥å¿—è®°å½•è§„åˆ’å®Œæ•´

### å¼€å‘ä¸­æ£€æŸ¥
- [ ] éµå¾ªå‘½åè§„èŒƒ
- [ ] å‡½æ•°èŒè´£å•ä¸€
- [ ] é¿å…æ·±å±‚åµŒå¥—
- [ ] é€‚å½“çš„æ³¨é‡Šè¯´æ˜
- [ ] å¼‚æ­¥æ“ä½œæ­£ç¡®å¤„ç†

### å¼€å‘åæ£€æŸ¥
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡â‰¥80%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] ESLintæ£€æŸ¥é€šè¿‡
- [ ] ä»£ç æ ¼å¼åŒ–è§„èŒƒ
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡

### æäº¤å‰æ£€æŸ¥
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] ä»£ç å®¡æŸ¥å®Œæˆ
- [ ] æ–‡æ¡£æ›´æ–°å®Œæ•´
- [ ] å˜æ›´æ—¥å¿—è®°å½•
- [ ] å®‰å…¨æ£€æŸ¥é€šè¿‡
